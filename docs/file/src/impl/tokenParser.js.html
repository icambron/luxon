<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">Luxon</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
<link data-ice="userStyle" rel="stylesheet" href="user/css/0-styles.css">
</head>
<body class="layout-container" data-ice="rootContainer">

<header><span class="luxon-title">Luxon</span>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/moment/luxon" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/datetime.js~DateTime.html">DateTime</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/duration.js~Duration.html">Duration</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/info.js~Info.html">Info</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/interval.js~Interval.html">Interval</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/settings.js~Settings.html">Settings</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-interface">I</span><span data-ice="name"><span><a href="class/src/zone.js~Zone.html">Zone</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/impl/tokenParser.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { Util } from &apos;./util&apos;;
import { Formatter } from &apos;./formatter&apos;;
import { FixedOffsetZone } from &apos;../zones/fixedOffsetZone&apos;;
import { IANAZone } from &apos;../zones/IANAZone&apos;;

const MISSING_FTP = &apos;missing Intl.DateTimeFormat.formatToParts support&apos;;

function intUnit(regex, post = i =&gt; i) {
  return { regex, deser: ([s]) =&gt; post(parseInt(s)) };
}

function fixListRegex(s) {
  // make dots optional and also make them literal
  return s.replace(/\./, &apos;\\.?&apos;);
}

function stripInsensitivities(s) {
  return s.replace(/\./, &apos;&apos;).toLowerCase();
}

function oneOf(strings, startIndex) {
  if (strings === null) {
    return null;
  } else {
    return {
      regex: RegExp(strings.map(fixListRegex).join(&apos;|&apos;)),
      deser: ([s]) =&gt;
        strings.findIndex(i =&gt; stripInsensitivities(s) === stripInsensitivities(i)) + startIndex
    };
  }
}

function offset(regex, groups) {
  return { regex, deser: ([, h, m]) =&gt; Util.signedOffset(h, m), groups };
}

function simple(regex) {
  return { regex, deser: ([s]) =&gt; s };
}

function unitForToken(token, loc) {
  const one = /\d/,
    two = /\d\d/,
    three = /\d{3}/,
    four = /\d{4}/,
    oneOrTwo = /\d\d?/,
    oneToThree = /\d(?:\d{2})?/,
    twoToFour = /\d\d(?:\d{2})?/,
    literal = t =&gt; ({ regex: RegExp(t.val), deser: ([s]) =&gt; s, literal: true }),
    unitate = t =&gt; {
      if (token.literal) {
        return literal(t);
      }

      switch (t.val) {
        // era
        case &apos;G&apos;:
          return oneOf(loc.eras(&apos;short&apos;, false), 0);
        case &apos;GG&apos;:
          return oneOf(loc.eras(&apos;long&apos;, false), 0);
        // years
        case &apos;yyyy&apos;:
          return intUnit(four);
        case &apos;yy&apos;:
          return intUnit(twoToFour, Util.untruncateYear);
        // months
        case &apos;M&apos;:
          return intUnit(oneOrTwo);
        case &apos;MM&apos;:
          return intUnit(two);
        case &apos;MMM&apos;:
          return oneOf(loc.months(&apos;short&apos;, false, false), 1);
        case &apos;MMMM&apos;:
          return oneOf(loc.months(&apos;long&apos;, false, false), 1);
        case &apos;L&apos;:
          return intUnit(oneOrTwo);
        case &apos;LL&apos;:
          return intUnit(two);
        case &apos;LLL&apos;:
          return oneOf(loc.months(&apos;short&apos;, true, false), 1);
        case &apos;LLLL&apos;:
          return oneOf(loc.months(&apos;long&apos;, true, false), 1);
        // dates
        case &apos;d&apos;:
          return intUnit(oneOrTwo);
        case &apos;dd&apos;:
          return intUnit(two);
        // ordinals
        case &apos;o&apos;:
          return intUnit(oneToThree);
        case &apos;ooo&apos;:
          return intUnit(three);
        // time
        case &apos;HH&apos;:
          return intUnit(two);
        case &apos;H&apos;:
          return intUnit(oneOrTwo);
        case &apos;hh&apos;:
          return intUnit(two);
        case &apos;h&apos;:
          return intUnit(oneOrTwo);
        case &apos;mm&apos;:
          return intUnit(two);
        case &apos;m&apos;:
          return intUnit(oneOrTwo);
        case &apos;s&apos;:
          return intUnit(oneOrTwo);
        case &apos;ss&apos;:
          return intUnit(two);
        case &apos;S&apos;:
          return intUnit(oneToThree);
        case &apos;SSS&apos;:
          return intUnit(three);
        // meridiem
        case &apos;a&apos;:
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case &apos;kkkk&apos;:
          return intUnit(four);
        case &apos;kk&apos;:
          return intUnit(twoToFour, Util.untruncateYear);
        // weekNumber (W)
        case &apos;W&apos;:
          return intUnit(oneOrTwo);
        case &apos;WW&apos;:
          return intUnit(two);
        // weekdays
        case &apos;E&apos;:
        case &apos;c&apos;:
          return intUnit(one);
        case &apos;EEE&apos;:
          return oneOf(loc.weekdays(&apos;short&apos;, false, false), 1);
        case &apos;EEEE&apos;:
          return oneOf(loc.weekdays(&apos;long&apos;, false, false), 1);
        case &apos;ccc&apos;:
          return oneOf(loc.weekdays(&apos;short&apos;, true, false), 1);
        case &apos;cccc&apos;:
          return oneOf(loc.weekdays(&apos;long&apos;, true, false), 1);
        // offset/zone
        case &apos;Z&apos;:
        case &apos;ZZ&apos;:
          return offset(/([+-]\d{1,2})(?::(\d{2}))?/, 2);
        case &apos;ZZZ&apos;:
          return offset(/([+-]\d{1,2})(\d{2})?/, 2);
        // we don&apos;t support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don&apos;t have any way to figure out what they are
        case &apos;z&apos;:
          return simple(/[A-Za-z_]+\/[A-Za-z_]+/);
        default:
          return literal(t);
      }
    };

  const unit = unitate(token) || {
    invalidReason: MISSING_FTP
  };

  unit.token = token;

  return unit;
}

function buildRegex(units) {
  return [units.map(u =&gt; u.regex).reduce((f, r) =&gt; `${f}(${r.source})`, &apos;&apos;), units];
}

function match(input, regex, handlers) {
  const matches = input.match(regex);

  if (matches) {
    const all = {};
    let matchIndex = 1;
    for (const i in handlers) {
      if (handlers.hasOwnProperty(i)) {
        const h = handlers[i],
          groups = h.groups ? h.groups + 1 : 1;
        if (!h.literal &amp;&amp; h.token) {
          all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
        }
        matchIndex += groups;
      }
    }
    return [matches, all];
  } else {
    return [matches, {}];
  }
}

function dateTimeFromMatches(matches) {
  const toField = token =&gt; {
    switch (token) {
      case &apos;S&apos;:
        return &apos;millisecond&apos;;
      case &apos;s&apos;:
        return &apos;second&apos;;
      case &apos;m&apos;:
        return &apos;minute&apos;;
      case &apos;h&apos;:
      case &apos;H&apos;:
        return &apos;hour&apos;;
      case &apos;d&apos;:
        return &apos;day&apos;;
      case &apos;o&apos;:
        return &apos;ordinal&apos;;
      case &apos;L&apos;:
      case &apos;M&apos;:
        return &apos;month&apos;;
      case &apos;y&apos;:
        return &apos;year&apos;;
      case &apos;E&apos;:
      case &apos;c&apos;:
        return &apos;weekday&apos;;
      case &apos;W&apos;:
        return &apos;weekNumber&apos;;
      case &apos;k&apos;:
        return &apos;weekYear&apos;;
      default:
        return null;
    }
  };

  let zone;
  if (!Util.isUndefined(matches.Z)) {
    zone = new FixedOffsetZone(matches.Z);
  } else if (!Util.isUndefined(matches.z)) {
    zone = new IANAZone(matches.z);
  } else {
    zone = null;
  }

  if (!Util.isUndefined(matches.h) &amp;&amp; matches.a === 1) {
    matches.h += 12;
  }

  if (matches.G === 0 &amp;&amp; matches.y) {
    matches.y = -matches.y;
  }

  const vals = Object.keys(matches).reduce((r, k) =&gt; {
    const f = toField(k);
    if (f) {
      r[f] = matches[k];
    }

    return r;
  }, {});

  return [vals, zone];
}

/**
 * @private
 */

export class TokenParser {
  constructor(loc) {
    Object.defineProperty(this, &apos;loc&apos;, { value: loc, enumerable: true });
  }

  explainParse(input, format) {
    const tokens = Formatter.parseFormat(format),
      units = tokens.map(t =&gt; unitForToken(t, this.loc)),
      disqualifyingUnit = units.find(t =&gt; t.invalidReason);

    if (disqualifyingUnit) {
      return { input, tokens, invalidReason: disqualifyingUnit.invalidReason };
    } else {
      const [regexString, handlers] = buildRegex(units),
        regex = RegExp(regexString, &apos;i&apos;),
        [rawMatches, matches] = match(input, regex, handlers),
        [result, zone] = matches ? dateTimeFromMatches(matches) : [null, null];

      return { input, tokens, regex, rawMatches, matches, result, zone };
    }
  }

  parseDateTime(input, format) {
    const { result, zone, invalidReason } = this.explainParse(input, format);
    return [result, zone, invalidReason];
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
